# Redux

- 자바스크립트의 상태관리 라이브러리이다.
- 컴포넌트 간의 데이터 공유에서 자식 컴포넌트들 간의 데이터는 부모 컴포넌트를 통해 주고 받아야하고, 자식 컴포넌트들이 많아지게 되면 상태관리가 매우 복잡해지게 되고, props driling 이슈가 생기게 된다.
- 이러한 이슈들을 해결하기 위해 전역 상태를 만들고 이를 저장하는 전역 상태 저장소를 만들게 되었다.
- 전역 저장소에 있는 상태 값을 아무 컴포넌트에서 끌어와서 쓸 수 있고, 상태값도 자유롭게 변경할 수 있기 때문에 props driling, 자식 컴포넌트 간의 데이터 공유의 문제를 해결할 수 있게 되었다.
  <br/><br/>

# 🍀 Redux이 나오게 된 배경

## 1. MVC 아키텍쳐의 한계

- 기존 MVC 패턴의 경우 Controller, Model, View가 있는데
- Controller는 Model에서 관리하는 데이터를 조회하거나 업데이트하는 역할을 하며, 변경된 Model의 데이터를 View에 반영해 준다.
- 또한 View를 통해 데이터를 입력하고 Model에 반영이 가능해 양방향으로 주고받는 형태였다.
- 하지만 양방향 데이터 통신은 프로젝트의 규모가 커질수록 수많은 View와 Model이 생겨나고, 이로인해 데이터가 어디로 흐르는지 파악하기 어렵고, 새 기능을 추가할 때마다 크고 작은 문제(Side Effect)가 생겼다.

## 2. Flux 아키텍쳐의 탄색

- 이러한 양방향 데이터 통신의 단점을 극복하기 위해 Flux 아키텍쳐가 나오게 되었다.
- Action-Dispatcher-Store-View의 형태로 순환이 반복될 수 있다는게 특징이다.
- Action이 발생하면 dispatcher에 의해 store에 변경된 사항이 저장되고, 그 저장된 데이터들에 의해 view가 변경되는 단방향 패턴이다.
- 단방향 흐름으로 인해 로직을 파악하기 쉬워졌다.

## 3. Redux의 탄생

- Flux 패턴의 등장으로 Redux가 생기게 되었는데, Flux보다 조금 더 단순화되어 나왔다.
- 새로고침을 하면 저장 상태를 잃어버리는 기존의 Flux 방식에서 Redux의 도입으로 코드가 변경되어도 기존의 상태를 유지할 수 있게 되었다.

<br/>

# 🍀 Redux의 3가지 원칙

## 1. Redux는 단일 store다.

- 동일한 데이터는 항상 같은 곳에서 가지고 온다.
- 스토어라는 하나뿐인 데이터 공간이 있다.(여러 reducer를 써도 결국 store는 하나)

## 2. Redux는 읽기 전용이다.

- 리액트에서는 setState로, 리덕스에서는 action이라는 객체를 통해서 상태를 변경할 수 있다.

## 3. Reducer는 순수 함수여야 한다.

- 변경은 순수함수로만 가능하다.
- 따라서 매개변수 외의 값에 의존하면 안된다.
- store - action - reducer

# 🍀 Store, Action, Reducer, Dispatch

## 1. Store

- store는 상태가 관리되는 오직 하나의 공간이다.
- 어플리케이션에서 필요한 상태와 리듀서가 저장되어 있고, 컴포넌트에서 상태 정보가 필요할 때 스토어에 접근한다.

## 2. Action

- action은 상태를 변화시키려는 의도를 표현한 객체다.
- 상태를 변경해야 될 때, 어떠한 변화를 줄지 해당하는 액션을 발생시킬 수 있다.

## 3. Reducer

- action을 통해 상태를 변화 시키는 함수다.
- 현재 state와 action을 인자로 받아 store에 접근해 action에 맞춰 state를 변경한다.
- 순수 함수이어야 하기 때문에, 새로운 상태 객체를 만들어 반환한다.

## 4. Dispatch

- store의 내장 함수 중 하나로, action을 발생시킨다. action을 파라미터로 전달하고 reducer를 호출한다.
