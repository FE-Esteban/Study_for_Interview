## React를 사용하는 이유를 설명하세요

 - React는 UI를 구축하기 위한 자바스크립트 라이브러리이다. 
 - UI를 개발하기 위해서 컴포넌트 기반으로 애플리케이션을 제작하기 시작했다. 
 - 컴포넌트 단위 개발로 인해 가독성을 높이고, 캡슐화 확장성, 결합성, 재사용성과 같은 이점이 있다.



**1. Virtual DOM의 사용**
실제로 DOM을 제어하지 않고 중간에 Virtual DOM이라는 가상의 DOM을 두어 Virtual DOM이 변경될 떄, 
실제 DOM을 변경하도록 설계되어 있습니다. 
이러한 작업을 Reconciliation이라고 합니다. 
Virtual DOM은 불필요한 렌더링과정의 비효율성을 최소화하기 위해 탄생하게 되었습니다.
하지만, 이렇게 Virtual DOM을 사용한다 해서 무조건 DOM보다 좋고 빠른 것은 아닙니다. 

**2.컴포넌트 단위 개발**
컴포넌트는 레고 블록과 같이 작은 단위로 개발한 것을 조립하듯이 합치는 것입니다. 
이렇게 하면 컴포넌트의 가독성이 높고 간단하여 캡슐화, 확장성, 결합성, 재사용성과 같은 이점이 있다.

**3. jsx의 지원**
jsx는 자바스크립트에 대한 확장 구문으로서, 리액트에서 element를 제공해줍니다. 

---

**4. csr, ssr 지원 가능**

**5.다른 프레임워크와도 혼용 가능**
리액트는 라이브러리이기 때문에 다른 프레임워크나 라이브러리와 함꼐 사용할 수 있다. 


## 다른 웹 프레임워크 와 비교

React
- 페이스북의 지원
- 가장 거대한 커뮤니티
- 단방향 바인딩
- virtual DOM
- 라이브러리


Angular
- TypeScript 기반의 오픈소스 프레임워크이다. 
- 구글의 지원
- 양 방향 바인딩
- 프레임워크

Vue
- Evan You 개인이 유지 보수
- 상대적으로 작지만 충분한 커뮤니티
- 양방향/단방향 둘 다 가능
- Virtual DOM
- 단일 파일 컴포넌트
- 프레임워크

## 바인딩 개념
Angular는 양방향 바인딩 개념으로 Model과 View가 연결되어 있어 데이터 값이 한쪽에서 변화하면 다른 쪽에서도 바로 업데이트가 진행된다.
- 장점 : 코드의 사용면에서 코드량을 크게 줄여줌
- 단점 : 변화에 따라 DOM 객체 전체를 렌더링해주거나 데이터를 바꿔주므로, 성능이 감소되는 경우가 있음

React는 단방향 데이터 바인딩이다.
- 장점 : 데이터 변화에 따른 성능 저하 없이 DOM 객체 갱신 가능, 데이터 흐름이 단방향(부모 => 하위 컴포넌트)이라, 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉬움
- 단점 : 변화를 감지하고 화면을 업데이트하는 코드를 매번 작성해야 함




## React 성능 향상을 위해 노력해보신 적 있으신가요? 어떻게 해야 하나요?

1. useMemo
```jsx
useMemo(()=> func, [input_dependency])
```
input_dependency가 있는 데이터가 변할 때에만 평균을 구하는 연산을 수행하도록 한다.
종속 변수들이 변하지 않으면 함수를 굳이 다시 호출하지 않고, 이전에 반환한 참조값을 재사용한다. 

2. React.memo 컴포넌트 메모이제이션
React.memo는 Hook이 아니기 때문에 클래스형 컴포넌트에서도 사용할 수 있다. 
함수형 컴포넌트에서는 shouldComponentUpdate를 사용할 수 없는데, 리액트 공식 문서에서는 그 대안으로 React.memo를 제시하고 있고,
우리는 이것을 통해 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정하여 함수형 컴포넌트의 리렌더링 성능을 최적화 해줄 수 있다. 
React.memo는 콜백함수를 이용해 메모이제이션을 적용할지 여부를 판단할 수 도 있다. 

3. useCallback
useMemo가 리턴되는 값을 memoize 시켜주었는데, useMemo와 비슷한 useCallback은 함수선언을 memoize하는데 사용된다.


4. 자식 컴포넌트의 props로 객체를 넘겨줄 경우 변형하지 말고 넘겨주기

props로 전달한 객체가 동일한 값이어도 새로 생성된 객체는 이전 객체와 다른 참조 주소를 가진 객체이기 때문에 자식 컴포넌트는 메모이제이션이 되지 않는다. 
생성자 함수나 객체 리터럴로 객체를 생성해서 하위 컴포넌트로 넘겨주는 방식이 아닌,
state를 그대로 하위 컴포넌트에 넘겨주어 필요한 데이터 가공을 그 하위컴포넌트에서 해주는 것이 좋다. 


5. 컴포넌트를 매핑할 때에는 key값으로 index를 사용하지 않는다.
리액트에서 map을 사용할 때 반드시 고유 key를 부여하도록 강제하고 있는데, 이렇게 index값으로 key 값을 부여하면 좋지 않다. 
왜냐하면, 어떤 배열에 중간에 어떤 요소가 삽인될 때 그 중간 이후에 위치한 요소들은 전부 index가 변경된다.
이로 인해 key 값이 변경되어 React는 key가 동일할 경우, 동일한 DOM Element를 보여주기 때문에 예상치 못한 문제가 발생한다. 
또한 데이터가 key와 매치가 안되어 서로 꼬이는 부작용도 발생한다.

**그러면 index 요소는 반드시 사용하면 안되는 걸까?**
배열의 요소가 필터링, 정렬 삭제, 추가 등의 기능이 들어간다면 문제가 발생할 수 있으나 다음과 같은 경우에는 index로 사용해도 무방하다.
다만, 가급적이면 코드의 일관성을 위해 최대한 index를 사용 안하는 것을 권장한다.

- 배열과 각 요소가 수정, 삭제, 추가 등의 기능이 없는 단순 렌더링만 담당하는 경우
- id로 쓸만한 unique한 값이 없을 경우
- 정렬 혹은 필터 요소가 없어야 함

6. useState의 함수형 업데이트
기존의 useState를 사용하며, 대부분 setState시에 새로운 상태를 파라미터로 넣어주었다. 
setState를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수도 잇는데
이렇게 하면 **useCallback을 사용할 때 두 번째 파라미터로 넣는 배열에 값을 넣어주지 않아도 된다.**



7. input에 onChange 최적화
input 태그에 onChange 이벤트를 줄 때 타이필 할 때마다 해당 컴포넌트가 렌더링 되어, 최적화 방법을 많이 찾곤 한다.
useRef를 사용하는 방법


## React 라이프 사이클
리액트는 컴포넌트 기반의 view를 중심으로한 라이브러리이다. 
컴포넌트의 라이프 사이클
컴포넌트 : 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈

## 클래스형 / 함수형  컴포넌트의 라이프 사이클
|분류|클래스형컴포넌트|함수형컴포넌트|
|---|---|---|
|Mounting|constructor()|함수형 컴포넌트 내부|
|Mounting|render()|return()|
|Mounting|ComponentDidMount()|useEffect()|
|Updating|componentDidUpdate()|useEffect()|
|UnMounting|componentWillUnmount()|useEffect()|



## 함수형 컴포넌트의 라이프 사이클(생명 주기)
