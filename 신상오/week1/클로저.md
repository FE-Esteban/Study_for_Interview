# 클로저

> 어떤 함수에서 선언한 변수를 참조하는 **내부함수를 외부로 전달할 경우** <br />
> 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지않는 현상
>
> 즉, `함수 A`에서 선언한 변수 `a`를 참조하는 `내부함수 B`를 외부로 전달할 경우 <br /> `함수 A`의 실행 콘텐스트가 종료된 이후에도 변수 `a`가 사라지지 않는 현상

Ex)

```javascript
var outer = function () {
  var a = 1;
  var inner = function () {
    console.log(++a); // 2
  };

  inner();
};

outer();

console.log(a); // a is not defined
```

```javascript
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner;
};

var outerResult = outer();
console.log(outerResult()); // 2
console.log(outerResult()); // 3
```

위 두 예시 코드처럼 outer 함수가 실행이 끝난 시점에도
outer 내부에 선언된 inner 함수를 통해서
outer 함수 내부 변수인 a를 참조할 수 있는데
이런 현상을 **클로저**라고 한다.

<hr />

# 클로저와 메모리의 관리

## **클로저**와 연관된 **가비지 컬렉터**의 동작 원리

> 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 <br /> 그 값은 수집 대상에 포함시키지 않는다.

이런 특징 때문에 외부함수의 실행이 종료되더라도 외부 함수의 어휘적 환경을 <br /> 참조하고 있는 내부함수에서 외부 함수의 변수를 참조할 수 있다.

### 메모리 누수

> 개발 의도와 다르게 특정 값의 참조 카운트가 0이 되지 않아<br /> 가비지 컬렉터의 수거 대상이 되지 않는 경우

클로저로 인해 메모리 누수가 발생될 경우에는 클로저 필요성이 사라졌을때 <br />해당 식별자에 참조형이 아닌 기본형 데이터 (`null` 또는 `undefined`)를 할당하면 된다.

<hr />

# 클로저 활용 사례

## 콜백 함수 내부에서 외부 데이터 사용

## 접근 권한 제어 (정보 은닉)

## 부분 적용 함수

## 커링 함수
